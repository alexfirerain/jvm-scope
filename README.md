## Работа JVM на примере
В начале Машина грузит и инициализирует системы _загрузки классов_,
_управления памятью_ и _процесса выполнения_.
```java
public class JvmComprehension {
```
Загрузчик Приложения (Application ClassLoader) считывает класс `JvmComprehension`,

`@?` управление передаётся Платформенному Загрузчику (Platform), а затем Корневому (Bootstrap),
после чего начинается поиск такого класса загрузчиками в обратном порядке, пока наконец класс не
будет загружен тем же Системным загрузчиком (aka Application), с которого начиналось.

Загрузчик _верифицирует_ текст с точки зрения синтаксиса и загружает в служебную область (_метаспейс_)
данные об этого класса полях (в данном случае только служебные) и методах (в данном случае два статических).

`@?` в строкохранилище (_стринг-пуле_) _инициализируется константа_ `"finished"`. 

```java
    public static void main(String[] args) {
```
На вершине стопки вызовов (_стэка_) создаётся `main`-_фрейм_, в нём создаются переменные `i`, `o` и `ii`.
Поскольку приложение однопоточное, это будет единственная стопка.
```java
        int i = 1;  
```
Значение `i` инициализируется внутри _фрейма_ равным `1`. 

`@?` Класс `Object` к этому моменту должен быть прогружен.

```java
        Object o = new Object();
```
В куче (_хипе́_) создаётся экземпляр класса `Object`, он связывается с переменной `o` внутри фрейма.

`@?` Класс `Integer` к этому моменту должен быть прогружен.
```java
        Integer ii = 2;
```
В куче (_хипе́_) создаётся экземпляр класса `Integer` со значением `2`, он связывается с переменной `ii` внутри _фрейма_.
```java
        printAll(o, i, ii);
```
На вершине стопки вызовов (_стэка_) создаётся _новый фрейм_ – `printAll`.
В него копируются три ранее инициализированные переменные из `main`.

Управление передаётся в новый _фрейм_ → выполняется метод `printAll()` →

{ ... }

→ управление возвращается в `main`
```java
        System.out.println("finished");
```
На вершине _стэка_ снова создаётся фрейм `println`,
в который на сей раз передаётся заранее подготовленный литерал.
Производится вывод строки на экран и уничтожение _фрейма_. Управление возвращается в `main`.

```java
    } // конец метода main()
```
Завершение метода `main`, соответствующий фрейм уничтожается со всем содержимым,
выполнение программы подходит к концу.

```java
    private static void printAll(Object o, int i, Integer ii) {
```
→ Новый фрейм на вершине _стэка_, в нём один примитив и две ссылки.

```java
        Integer uselessVar = 700;
```
Внутри фрейма `printall` создаётся переменная `uselessVar`, 
в _куче_ создаётся связанный ссылкой соответствующий объект типа `Integer` со значением `700`. 

`@?` К этому моменту должны быть прогружены классы `System` и тот,
к которому относится объект в его поле`out`. Либо их загрузили в самом начале?
```java
        System.out.println(o.toString() + i + ii);
```
На вершине _стэка_ вызовов создаётся _новый фрейм_ – `println`,
в него копируются те же три переменные, что были переданы в `printAll`, и создаются три аргумента.

На вершине _стэка_ создаётся _новый фрейм_ – `toString`, в него передаётся ссылка не объект `o`,
затем происходит вычисление, в результате которого в _строкохранилище_ создаётся соответствующая строка.
Фрейм уничтожается, ссылка на вычисленную строку _возвращается_ обратно во фрейм `printAll`
и фиксируется в качестве первого аргумента. Соответственно, в низлежащий `println` возвращается и управление процессом выполнения.

`@?` У переменной `i`, вероятно, так же вызывается `.toString()`, аналогично разрешающий значение для второго аргумента.

У переменной `ii` так же неявно вызывается `.toString()`, аналогично определяющий третий аргумент.

Судя по всему, для осуществления _конкатенации_ трёх строковых аргументов
тоже должен быть создан транзиентный фрейм,
вычисляющий итоговую строку, возвращаемую во фрейм `printAll`.

Средствами класса `System`, умеющего договориться с ОС об использовании системных функций,
происходит вывод вычисленной строки на экран.

```java        
    } // конец метода printAll()
```
Метод ничего не возвращает, выполнив свою работу, фрейм `printAll` уничтожается со всем содержимым.
Объект `Integer` со значением `700` оказался уже бесполезным (ничто на него не ссылается).
Возможно, _Сборщик Мусора_ уберёт его из _Эдема_ (Eden) сразу же.
У остальных переменных есть шанс попасть в _поколение выживших_.

Управление возвращается во фрейм `main` →
```java    
}       // конец класса
```
После завершения метода `main` и, таким образом, опустошения _стэка_ вызовов,
программа может завершить свою работу, а JVM – очистить всю занятую при этом память.
_Сборщик мусора_, возможно, вовсе не успеет вступить в игру, ведь выполнение было таким скоротечным.